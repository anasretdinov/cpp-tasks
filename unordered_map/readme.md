В этой задаче Вам предлагается реализовать упрощенный аналог одного из популярных контейнеров STL - unordered_map’а. Вам очень пригодится List, написанный ранее. {\bf Использовать std::list нельзя.}

На этот раз нужно будет правильно поддержать не только итераторы и аллокаторы, но еще и {\bf move-семантику}. Все классы, которые вы используете для своей реализации UnorderedMap (например, List), также должны корректно поддерживать move-семантику. В частности, вам нужно дописать поддержку move-семантики в List, если ранее он ее не поддерживал.

Напишите шаблонный класс UnorderedMap<Key, Value, Hash, Equal, Alloc> - упрощенный аналог std::unordered_map.
Здесь Key - тип ключа, Value - тип значения, Hash - используемая хеш-функция (по умолчанию std::hash<Key>, реализовывать hash не надо), Equal - используемый сравниватель (по умолчанию - std::equal_to<Key>), Alloc - используемый аллокатор (по умолчанию - std::allocator<std::pair<const Key, Value>>).

Типы Key и Value не обязаны иметь конструкторы по умолчанию, копирующий конструктор и копирующий оператор присваивания. Для создания UnorderedMap с ними должно быть достаточно, чтобы они имели лишь move-конструктор и move-оператор присваивания.

Внутри UnorderedMap публично определим тип NodeType как std::pair<const Key, Value>. (В std::unordered_map аналогичный тип называется value_type.)

Должна быть реализована следующая функциональность:
\begin{itemize}
\item Конструкторы (в т.ч. копирования и {\bf перемещения}), деструктор, копирующий и {\bf перемещающий} операторы присваивания.
\item Методы [] и at(key), работающие в среднем за O(1). Метод [] определен только для неконстантных объектов, он создает Value по умолчанию, если по данному ключу ничего не было. Метод at(key) в таком случае кидает исключение. {\bf Если в метод [] передано rvalue и оказалось, что такого ключа в мэпе не было, то нужно эффективно создать Node с таким ключом: не копировать его, а перемещать.} 
\item Метод size(), за O(1) возвращающий текущее количество элементов в контейнере.
\item Внутренние типы iterator и const_iterator, удовлетворяющие требованиям ForwardIterator. Разыменование константного итератора не должно позволять поменять объект под ним.
\item Методы begin(), end(), cbegin(), cend().
Итераторы должны быть реализованы так, чтобы код
for (auto it = m.begin(); it != m.end(); ++it); позволял пройтись по всем лежащим в контейнере элементам за линейное время {\bf от количества этих элементов} (а не от размера хеш-таблицы). Инкрементация любого итератора должна происходить {\bf за гарантированное O(1).}
\item Метод insert, принимающий ссылку на NodeType и возвращающий pair<iterator, bool>, где bool означает “произошла ли вставка”, а iterator указывает на элемент с данным ключом в контейнере (либо уже лежавший там, либо только что вставленный). {\bf Метод insert должен эффективно обрабатывать как lvalue, так и rvalue: не копировать переданную ему NodeType, если она была rvalue!} Вставка элемента должна работать за O(1) в среднем.
\item Метод insert от пары InputIterator’ов на NodeType, делающий вставку всего данного диапазона в контейнер. Кстати, разыменование итератора необязательно дает lvalue, оно может давать и rvalue-ссылку. Например, так ведет себя std::move_iterator. В таком случае вы должны вставлять элементы из-под этого итератора в UnorderedMap не копированием, а перемещением.
\item Метод emplace(Args&&... args), который самостоятельно конструирует NodeType от переданных аргументов (без их копирования, если это возможно) и, не копируя, вставляет полученный объект NodeType в контейнер, если это возможно. Возвращаемый тип - такой же, как у insert от NodeType.
\item Метод erase от итератора, а также от пары итераторов (удаляющие один элемент и диапазон элементов соответственно). Итераторы на элементы, которые не были удалены, должны не инвалидироваться после вызова erase.  Удаление одного элемента должно работать за O(1) в среднем.
\item Метод find по ключу, возвращающий итератор на найденный элемент или end(), если элемент не был найден. Поиск должен работать в среднем за O(1).
\item Методы reserve, load_factor и max_load_factor, аналогичные методам STL, позволяющие управлять размером хеш-таблицы.
\item Метод swap с другим UnorderedMap. Должен работать за O(1). При swap итераторы в обоих UnorderedMap не должны инвалидироваться, а должны продолжать указывать на те же элементы, куда указывали ранее.
\end{itemize}

Вставка и удаление любого количества элементов в UnorderedMap не должны инвалидировать указатели и ссылки на остальные элементы UnorderedMap'а (то есть на NodeType). Однако вставка может инвалидировать итераторы, если во время нее произошел rehash.

Методы insert и emplace, вставляющие одиночные элементы, должны быть строго безопасны относительно исключений, кроме случая, когда исключение кидается хеш-функцией.

Как и List, UnorderedMap должен быть allocator-aware контейнером. Никаких прямых обращений к new/delete быть не должно, всё должно происходить через allocator_traits. Во время конструирования и присваивания UnorderedMap'ов должны правильно использоваться свойства и методы аллокаторов select_on_container_copy_construction, propagate_on_container_copy_assignment, propagate_on_container_move_assignment, propagate_on_container_swap. 

Если аллокатор является структурой без каких-либо полей, то такой аллокатор не должен увеличивать sizeof объекта UnorderedMap. То есть тривиальный аллокатор как поле UnorderedMap должен занимать 0 байт. {\bf То же самое требование распространяется и на объект Hash, и на объект Equal.}


В вашем файле должна отсутствовать функция main(), а сам файл должен называться unordered_map.h. Ваш код будет вставлен посредством команды #include "unordered_map.h" в программу, содержащую тесты; вследствие этого, код необходимо отправлять в файле со строго соответствующим именем!