# Variant

Напишите класс `Variant` – упрощенный аналог `std::variant` из C++17.
Поддержите следующие методы:
- Конструктор по умолчанию. Инициализирует `Variant` первым типом из списка типов, придавая этому типу его значение по умолчанию.
- Конструктор от `T&&`. Должен проинициализировать `Variant` таким из его возможных типов, к которому наиболее предпочтительно приведение типа `T` с точки зрения правил разрешения перегрузки.
    - Примеры:
        - ```
            Variant<int, std::string, double>(5.0f);
          ``` 
          должно активировать у `Variant` тип `double`.
        - ```
            char c = 'a'; 
            Variant<int*, const int*, char*>(&c);
          ``` 
          должно активировать у `Variant` тип `char*`.
        - ```
            const int x = 5; 
            Variant<int*, const int*, char*>(&x); 
          ```
          должно активировать у `Variant` тип `const int*`.
        - ```
            Variant<int, double>(5.0f);
          ```
          должно привести к ошибке компиляции, т.к. невозможно выбрать наилучшее соответствие.
    - Если `Variant` с помощью данного конструктора создается от *lvalue*, то оно должно быть скопировано, а если от *rvalue* – оно должно быть перемещено в `Variant`.
- Оператор присваивания от `T&&`. Должен проинициализировать `Variant` новым типом, выбирая его по тем же правилам, как и в вышеописанном конструкторе от `T&&`.
    - Если выбранный тип совпадает с типом, который хранился в `Variant` до этого, то должен вызваться оператор присваивания у данного типа (вместо его уничтожения и нового конструирования), в противном случае – предыдущее значение `Variant` должно быть корректно уничтожено, прежде чем создано новое. 
    - Если присваиваемое выражение является *lvalue*, то оно должно быть скопировано, а если *rvalue* – оно должно быть перемещено.
    - Если во время копирования (или перемещения) нового значения в `Variant` вылетает исключение, при этом тип `Variant` должен был измениться, то `Variant` должен перейти в особое состояние *"пустой"*, в котором он не хранит никакого значения. Если же исключение вылетело во время присваивания типа `T` (который не менялся), то `Variant` должен остаться в том состоянии, в котором его оставил этот оператор присваивания.
    - Если ни один из возможных типов `Variant` нельзя создать из T&& или если возникает неоднозначность при выборе альтернативы, это должно приводить к ошибке компиляции.
- Методы `emplace<typename T, typename… Args>` и `emplace<size_t I, typename...Args>`. Позволяют сконструировать новое значение `Variant`, имеющее тип `T` (или, соответственно, тип с номером `I`), непосредственно из аргументов конструктора типа `T` (или типа с номером `I`). Возвращают ссылку на новое значение. При этом предыдущее значение `Variant` должно быть корректно уничтожено (если таковое было). *Аргументы должны передаваться в конструктор T с помощью механизма perfect forwarding*.
    - Если во время создания нового значения `Variant` вылетает исключение, то `Variant` должен перейти в особое состояние *"пустой"*, в котором он не хранит никакого значения.
    - Если `Variant` не имеет альтернативы `T`, или имеет более одной альтернативы типа `T`, или `T` нельзя создать из переданных аргументов, то вызов `emplace<T, Args...>` должен приводить к ошибке компиляции.
    - Обратите внимание: `emplace`, в отличие от оператора присваивания, всегда уничтожает предыдущее значение `Variant`, даже если его тип был таким же, как и у нового значения.
- Метод `index`, возвращающий номер того типа из пакета аргументов, которым сейчас проинициализирован `Variant`. Если `Variant` сейчас пустой, поведение не специфицировано.
- Метод `valueless_by_exception`, возвращающий `true` тогда и только тогда, когда `Variant` находится в состоянии *"пустой"*.
- Конструктор копирования и конструктор перемещения из такого же `Variant`, как данный.
- Оператор копирующего присваивания и оператор перемещающего присваивания от такого же `Variant`, как данный.
- Деструктор (разумеется).
    
Кроме этого, реализуйте функции – не члены класса:
- `holds_alternative<T>`, возвращающая `true` тогда и только тогда, когда текущий тип, хранящийся в `Variant`, равен `T`. Если `T` отсутствует в списке возможных типов данного `Variant`, вызов должен приводить к CE. Равенство типов должно учитывать константность: `int` и `const int` – **разные типы**!
- `get<T>`, принимающая ссылку на `Variant` и возвращающая ссылку на его текущее значение, если оно сейчас имеет тип `T`. Равенство типов должно учитывать константность: `int` и `const int` – **разные типы**!
    - Если `T` отсутствует в списке возможных типов данного `Variant`, вызов должен приводить к CE.
    - Если `T` присутствует в списке возможных типов, но хранящийся в `Variant` тип сейчас не `T`, должно быть брошено исключение (не специфицировано, какое).
    - Функция `get` должна уметь принимать как *lvalue*-, так и *rvalue*-ссылки на `Variant`, причем как константные, так и неконстантные, и возвращаемая ссылка на `T` должна быть соответствующей.
- `get<Index>`, принимающая ссылку на `Variant` и возвращающая ссылку на его текущее значение, если индекс текущего типа в списке возможных типов равен `Index`.
    - Если индекс типа сейчас не равен `Index`, должно быть брошено исключение (не специфицировано, какое).
    - Функция должна уметь принимать как *lvalue*-, так и *rvalue*-ссылки на `Variant`, причем как константные, так и неконстантные, и возвращаемая ссылка на `T` должна быть соответствующей.
- `visit`, принимающая объект-визитор, а также переменное число объектов `Variant`. Визитор -- это функциональный объект, который должен быть вызван от объекта, лежащего в `Variant`.
    - Если визитор умеет вызываться от разных типов, то он должен вызваться от того типа, который сейчас лежит в `Variant`, применяя правила перегрузки. При этом, если визитор таков, что его вызовы от разных типов имеют неодинаковый возвращаемый тип, то такое поддерживать не нужно, это должно приводить к CE.
    - `visit` должна корректно обрабатывать как *lvalue*, так и *rvalue*, причем как у объекта визитора, так и у объектов `Variant`.
	- Если в `visit` передано несколько объектов `Variant` (пусть их передано $n$ штук), то нужно вызвать визитор от $n$ аргументов, где $i$-й аргумент должен быть такого типа, который сейчас лежит в $i$-м по порядку объекте `Variant`. При этом по-прежнему надо сохранить вид value при вызове.