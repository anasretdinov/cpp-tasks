# Function

Напишите класс `Function` – упрощенный аналог `std::function` из C++11.

У этого класса должен быть один шаблонный аргумент – тип функции. Тип функции записывается как `ReturnType(Args...)`. Для всех остальных типов (не являющихся функциями) класс `Function` должен быть оставлен без опеделения.

`Function` должна хранить в себе некий *callable*-объект. Формальное определение `Callable` можно прочитать [тут](https://en.cppreference.com/w/cpp/named_req/Callable). Неформально, это может быть одно из следующего:
- C-style указатель на функцию;
- объект с определенным `operator()` от соответствующих типов;
- замыкание (т.е. объект, сгенерированный из лямбда-выражения);
- результат функции `std::bind`;
- указатель на метод класса;
- указатель на поле класса;
- `std::reference_wrapper` на что-либо из вышеперечисленного.

Кроме того, `Function` накладывает требование, чтобы хранимый в ней объект был *copy-constructible*.

В классе `Function` должны быть определены:
- Шаблонный конструктор от `F&&`, где `F` – некий *callable* тип. Сохраняет в `Function` соответствующий объект путем копирования или перемещения.
- Конструктор по умолчанию, а также конструктор от `nullptr_t`. Создают `Function`, которая ничего не хранит.
- `operator()` от соответствующих типов, возвращающий `Ret`. Делает вызов хранящегося в `Function` объекта. Этот вызов не всегда делается напрямую через `operator()`. Для указателей на члены, а также для объектов `std::reference_wrapper` синтаксис вызова должен быть другим. Чтобы сделать вызов правильно для любого *callable*-объекта, можно использовать функцию `std::invoke` или написать ее аналог. `operator()` является константным для `Function`, но это не значит, что он позволяет вызывать лишь константные версии `operator()` у хранимого объекта. Если делается вызов `operator()` у пустой `Function`, то нужно бросить исключение `std::bad_function_call`.
- Конструктор копирования и конструктор перемещения. Соответственно, делают глубокое копирование либо перемещение объекта, хранимого в `Function`.
- Деструктор. Уничтожает хранимый объект.
- Оператор присваивания копированием и перемещением. Подменяет хранимый объект на новый, корректно уничтожая ранее хранимый объект.
- Оператор присваивания от `F&&`, а также от `std::reference_wrapper<F>`.
- Оператор конверсии в `bool`. Позволяет проверить, пуста ли данная Function.
- Метод `target()`, возвращающий C-style указатель на хранимую функцию или функциональный объект.
- Метод `target_type()`, возвращающий `std::type_info` от хранимого объекта.

Помимо всего вышесказанного, должны быть выполнены следующие требования:
- Small Object Optimization: **eсли размер хранимого объекта небольшой (скажем, не более $16$ байт), то не должно происходить никаких выделений динамической памяти для его хранения**. В частности, C-style указатели на функции, замыкания с пустым списком захвата, а также объекты `std::reference_wrapper` должны храниться на стеке.
- Вызов функции должен требовать как можно меньше разыменований указателей. Адрес функции, которая должна быть вызвана при обращении к `operator()` у Function, должен по возможности храниться на стеке в полях Function и не требовать никаких дополнительных прыжков по указателям для своего отыскания. В частности, **виртуальные функции в этой задаче использовать запрещено**. В вашей программе слово `virtual` не должно встречаться ни разу.

Кроме всего вышеописанного, реализуйте класс `MoveOnlyFunction` – аналог `std::move_only_function` из C++23. Этот класс почти во всем аналогичен `std::function`, кроме того, что он поддерживает *move-only* объекты, не требуя от них быть *copy-constructible*. Реализуйте аналогичные методы для этого класса, соблюдая аналогичные требования. Постарайтесь переиспользовать свой код, следуя принципу [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).